<!DOCTYPE html>
<html>
<head>
    <title>AURA - Real-Time Kinematics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #080808; color: #00ff41; display: flex; flex-direction: column; align-items: center; margin: 0; height: 100vh; }
        
        /* Main Layout */
        #main-grid { display: grid; grid-template-columns: 640px 400px; gap: 20px; margin-top: 20px; }
        
        /* Video Container */
        #video-box { position: relative; width: 640px; height: 480px; border: 2px solid #333; border-radius: 10px; overflow: hidden; background: #000; }
        video, canvas.output_canvas { position: absolute; top: 0; left: 0; width: 640px; height: 480px; transform: scaleX(-1); }
        
        /* Right Side Panel (UI & Graph) */
        #side-panel { display: flex; flex-direction: column; gap: 15px; height: 480px; }
        
        /* The Live Graph Container */
        #graph-container { flex-grow: 1; background: #111; border: 2px solid #333; border-radius: 10px; padding: 10px; position: relative; }
        
        /* Metrics & Buttons */
        .metric-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .metric-box { background: #222; padding: 15px; border-radius: 8px; border-left: 4px solid #00ff41; }
        .val-label { font-size: 0.8em; color: #aaa; letter-spacing: 1px; }
        .val-data { font-size: 1.8em; font-weight: bold; color: white; display: block; margin-top: 5px; }
        
        button { padding: 15px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; text-transform: uppercase; font-size: 1em; transition: 0.2s; }
        #calib-btn { background: #00d2ff; color: black; }
        #exam-btn { background: #00ff41; color: black; }
        button:disabled { opacity: 0.3; cursor: not-allowed; filter: grayscale(1); }
        
        /* Overlays */
        #status-bar { width: 100%; text-align: center; padding: 12px; background: #1a1a1a; color: #00ff41; font-weight: bold; letter-spacing: 1px; border-bottom: 2px solid #333; }
        #target-dot { position: fixed; width: 30px; height: 30px; background: #ff3e3e; border-radius: 50%; display: none; z-index: 100; box-shadow: 0 0 20px #ff3e3e; border: 2px solid white; }
        #flash-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: white; display: none; z-index: 101; opacity: 0; transition: opacity 0.1s; }

        /* Final Scoreboard Modal */
        #results-modal { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 500px; background: #1a1a1a; border: 3px solid #00ff41; padding: 30px;
            z-index: 200; display: none; text-align: center; border-radius: 20px;
            box-shadow: 0 0 100px rgba(0,255,65,0.3);
        }
        .status-header { font-size: 2em; margin: 0; color: white; }
        .status-pill { padding: 10px 30px; border-radius: 30px; font-weight: bold; margin: 20px 0; display: inline-block; font-size: 1.4em; }
        .normal { background: #00ff41; color: black; box-shadow: 0 0 30px #00ff41; }
        .depressed { background: #ff3e3e; color: white; box-shadow: 0 0 30px #ff3e3e; border-color: #ff3e3e; }
    </style>
</head>
<body>

    <div id="status-bar">AURA SYSTEM INITIALIZED: CALIBRATION REQUIRED</div>
    <div id="flash-overlay"></div>
    <div id="target-dot"></div>

    <div id="results-modal">
        <h2 style="color: #aaa; margin: 0; font-size: 1em;">DIAGNOSTIC RESULT</h2>
        <div id="cns-pill" class="status-pill">ANALYZING...</div>
        <h1 id="final-status-text" class="status-header">NORMAL</h1>
        <p style="color: #ccc; margin-top: 20px;">Ocular kinematics fall within physiological baseline thresholds.</p>
        <button onclick="location.reload()" style="margin-top: 20px; width: 100%; background: #333; color: white;">DISMISS & RESET</button>
    </div>

    <div id="main-grid">
        <div id="video-box">
            <video id="webcam" autoplay playsinline style="display:none"></video>
            <canvas id="output_canvas" class="output_canvas"></canvas>
        </div>

        <div id="side-panel">
            <div id="graph-container">
                <canvas id="liveChart"></canvas>
            </div>
            
            <div class="metric-row">
                <div class="metric-box">
                    <span class="val-label">LIVE VELOCITY</span>
                    <span id="vel-val" class="val-data">0.00</span>
                </div>
                <div class="metric-box">
                    <span class="val-label">IRIS SIZE (%)</span>
                    <span id="plr-val" class="val-data">--</span>
                </div>
            </div>
            
            <button id="calib-btn">1. Calibrate Baseline</button>
            <button id="exam-btn" disabled>2. Start AURA Exam (30s)</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status-bar');
        const calibBtn = document.getElementById('calib-btn');
        const examBtn = document.getElementById('exam-btn');
        const dot = document.getElementById('target-dot');
        const flash = document.getElementById('flash-overlay');

        let history = [];
        let threshold = 0.25; // Default fallback
        let isCalibrating = false;
        let calibData = [];
        let examRunning = false;
        let examSaccadePeaks = [];
        let forceFail = false;
        let liveChart; // Global chart object

        // Force Fail Key (Press 'F')
        window.addEventListener('keydown', (e) => { if(e.key.toLowerCase() === 'f') forceFail = true; });

        // Initialize the Live Chart immediately
        function initLiveChart() {
            const ctxChart = document.getElementById('liveChart').getContext('2d');
            liveChart = new Chart(ctxChart, {
                type: 'line',
                data: {
                    labels: [], // Empty initially
                    datasets: [{
                        label: 'Ocular Velocity',
                        data: [],
                        borderColor: '#00ff41',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.1, // Slight curve for smoother look
                        fill: true,
                        backgroundColor: 'rgba(0, 255, 65, 0.1)'
                    }, {
                        label: 'Threshold',
                        data: [], // Will be filled dynamically
                        borderColor: '#ff3e3e',
                        borderDash: [5, 5],
                        borderWidth: 1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, // Disable generic animations for performance
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            suggestedMax: 1.0, // Fix Y-axis so it doesn't jump
                            grid: { color: '#222' },
                            ticks: { color: '#666' }
                        },
                        x: { display: false // Hide X-axis labels for clean look
                        }
                    },
                    plugins: { legend: { display: false } } // Hide legend
                }
            });
        }
        initLiveChart();

        async function runExam() {
            examRunning = true;
            examBtn.disabled = true;
            calibBtn.disabled = true;
            examSaccadePeaks = [];
            let currentPeak = 0;
            
            // Clear chart for new exam
            liveChart.data.labels = [];
            liveChart.data.datasets[0].data = [];
            liveChart.data.datasets[1].data = [];
            liveChart.update();

            status.innerText = "PHASE 1: SACCADIC TRIALS (TRACK THE DOT)";
            dot.style.display = 'block';
            
            // 5 Cycles of Left/Right movement
            for (let i = 0; i < 5; i++) {
                const positions = [{l:'10%', t:'50%'}, {l:'90%', t:'50%'}];
                for (let pos of positions) {
                    dot.style.left = pos.l; dot.style.top = pos.t;
                    // Reset peak tracker for this movement window
                    currentPeak = 0;
                    const peakTracker = setInterval(() => {
                        const currentVel = parseFloat(document.getElementById('vel-val').innerText);
                        if(currentVel > currentPeak) currentPeak = currentVel;
                    }, 50);

                    await new Promise(r => setTimeout(r, 1500));
                    clearInterval(peakTracker);
                    if(currentPeak > 0) examSaccadePeaks.push(currentPeak);
                }
            }
            dot.style.display = 'none';

            status.innerText = "PHASE 2: PUPILLARY STIMULUS (FLASH)";
            flash.style.display = 'block';
            flash.style.opacity = '1';
            await new Promise(r => setTimeout(r, 800));
            flash.style.opacity = '0';
            setTimeout(() => { flash.style.display = 'none'; }, 200);

            examRunning = false;
            showScoreboard();
        }

       function showScoreboard() {
    const modal = document.getElementById('results-modal');
    const pill = document.getElementById('cns-pill');
    const header = document.getElementById('final-status-text');
    
    const avgPeak = examSaccadePeaks.reduce((a, b) => a + b, 0) / examSaccadePeaks.length || 0;
    document.getElementById('final-saccade').innerText = avgPeak.toFixed(2);
    
    // Low threshold (1.5x) makes it easy to be "Normal"
    const isDepressed = avgPeak < (threshold * 1.2) || forceFail;
    
    if (isDepressed) {
        pill.innerText = "CNS DEPRESSION DETECTED";
        pill.className = "status-pill depressed";
        header.innerText = "ABNORMAL";
        header.style.color = "#ff3e3e";
    } else {
        pill.innerText = "CNS STATUS: STABLE";
        pill.className = "status-pill normal";
        header.innerText = "NORMAL";
        header.style.color = "#00ff41";
    }
    modal.style.display = 'block';
}

        calibBtn.onclick = () => {
            isCalibrating = true;
            calibData = [];
            status.innerText = "CALIBRATING BASELINE NOISE... REMAIN STILL";
            calibBtn.disabled = true;
            setTimeout(() => {
                isCalibrating = false;
                const avg = calibData.reduce((a, b) => a + b, 0) / calibData.length;
                // Set threshold slightly above average noise
                threshold = avg + 0.1; 
                status.innerText = `CALIBRATION COMPLETE. BASELINE: ${threshold.toFixed(2)}. READY.`;
                examBtn.disabled = false;
                calibBtn.style.background = "#333";
                calibBtn.innerText = "Calibrated âœ“";
            }, 4000);
        };

        examBtn.onclick = runExam;

        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.6});
        faceMesh.onResults(onResults);

        function onResults(results) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                if (!landmarks[468] || !landmarks[469] || !landmarks[473]) return;

                const leftIris = landmarks[468];
                const rightIris = landmarks[473];
                const now = performance.now();
                
                // Use average of both eyes for stability
                const avgX = (leftIris.x + rightIris.x) / 2;
                history.push({x: avgX, t: now});
                if (history.length > 5) history.shift();

                if (history.length > 2) {
                    const last = history[history.length-1];
                    const prev = history[history.length-2];
                    const dt = last.t - prev.t;
                    // Scaled Velocity Calculation
                    const v = (Math.abs(last.x - prev.x) / dt) * 2500;
                    
                    if (isCalibrating) calibData.push(v);
                    
                    document.getElementById('vel-val').innerText = v.toFixed(2);

                    // UPDATE LIVE GRAPH
                    if (examRunning && liveChart) {
                        // Add new data
                        liveChart.data.labels.push(''); 
                        liveChart.data.datasets[0].data.push(v);

                        // Sliding Window: Keep last ~300 frames (approx 10s at 30fps)
                        if (liveChart.data.labels.length > 300) {
                            liveChart.data.labels.shift();
                            liveChart.data.datasets[0].data.shift();
                        }

                       // Set Red Line to 1.5x the noise (Much easier to pass!)
                        const redLineValue = threshold;
                        liveChart.data.datasets[1].data = Array(liveChart.data.datasets[0].data.length).fill(redLineValue);
                        liveChart.update('none');
                    }
                }

                // Iris Size & Drawing
                const irisWidth = Math.sqrt(Math.pow(landmarks[469].x - landmarks[471].x, 2) + Math.pow(landmarks[469].y - landmarks[471].y, 2));
                document.getElementById('plr-val').innerText = (irisWidth * 100).toFixed(1) + "%";

                ctx.strokeStyle = "#00ff41";
                ctx.lineWidth = 2;
                [leftIris, rightIris].forEach(eye => {
                    ctx.beginPath();
                    ctx.arc(eye.x * canvas.width, eye.y * canvas.height, irisWidth * canvas.width * 0.6, 0, 2*Math.PI);
                    ctx.stroke();
                });
            }
            ctx.restore();
        }

        async function start() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                const process = async () => { await faceMesh.send({image: video}); requestAnimationFrame(process); };
                process();
            };
        }
        start();
    </script>
</body>
</html>